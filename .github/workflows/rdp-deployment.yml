name: RDP Server Deployment (Production)

on:
  workflow_dispatch:
    inputs:
      force_run:
        description: 'Force run even if another instance is running'
        required: false
        default: 'false'

jobs:
  deploy-rdp:
    runs-on: windows-latest
    timeout-minutes: 90
    permissions:
      contents: write  # Required to push connection details back to repository

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: System Information and Prerequisites
      run: |
        echo "=== SYSTEM INFORMATION ==="
        echo "OS: $env:OS"
        echo "Processor: $env:PROCESSOR_ARCHITECTURE"
        echo "User: $env:USERNAME"
        echo "PowerShell Version: $($PSVersionTable.PSVersion)"
        echo "Current Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')"
        echo "=============================="

        # Check SSH availability
        try {
          $sshVersion = ssh -V 2>&1
          echo "SSH Version: $sshVersion"
        } catch {
          echo "WARNING: SSH not found, attempting to install OpenSSH..."
          try {
            Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0
            echo "✓ OpenSSH Client installed"
          } catch {
            echo "✗ Failed to install OpenSSH: $_"
            exit 1
          }
        }

    - name: Enhanced RDP Configuration
      run: |
        echo "=== RDP CONFIGURATION ==="
        echo "Configuring Windows Remote Desktop with enhanced security..."

        try {
          # Enable Remote Desktop
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -name "fDenyTSConnections" -Value 0
          echo "✓ Remote Desktop enabled"

          # Configure firewall rules
          Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
          echo "✓ Firewall rules configured"

          # Disable Network Level Authentication (can cause issues with tunneled connections)
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "UserAuthentication" -Value 0
          echo "✓ Network Level Authentication disabled for better tunnel compatibility"

          # Set security layer to RDP Security Layer
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "SecurityLayer" -Value 0
          echo "✓ Security layer set to RDP"

          # Set encryption level to low for better compatibility
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "MinEncryptionLevel" -Value 1
          echo "✓ Encryption level set for compatibility"

          # Configure user account
          $username = "runneradmin"
          $password = "P@ssw0rd!"
          Set-LocalUser -Name $username -Password (ConvertTo-SecureString -AsPlainText $password -Force)
          echo "✓ User credentials configured"

          # Restart RDP service to apply configuration changes
          echo "Restarting RDP service to apply configuration..."
          Restart-Service -Name "TermService" -Force
          Start-Sleep -Seconds 3

          # Verify RDP service
          $rdpService = Get-Service -Name "TermService"
          if ($rdpService.Status -eq "Running") {
            echo "✓ RDP service restarted and running"
          } else {
            echo "⚠ RDP service not running, attempting to start..."
            Start-Service -Name "TermService"
            Start-Sleep -Seconds 2
            $rdpService = Get-Service -Name "TermService"
            if ($rdpService.Status -eq "Running") {
              echo "✓ RDP service started successfully"
            } else {
              echo "✗ Failed to start RDP service"
            }
          }

          # Check if RDP port is listening
          Start-Sleep -Seconds 2  # Give service time to bind to port
          $rdpPort = Get-NetTCPConnection -LocalPort 3389 -ErrorAction SilentlyContinue
          if ($rdpPort) {
            echo "✓ RDP port 3389 is listening"
            echo "  Listening on: $($rdpPort.LocalAddress):$($rdpPort.LocalPort)"
          } else {
            echo "⚠ RDP port 3389 not detected"
            echo "Checking all listening ports..."
            Get-NetTCPConnection -State Listen | Where-Object {$_.LocalPort -eq 3389} | ForEach-Object {
              echo "  Found RDP port: $($_.LocalAddress):$($_.LocalPort)"
            }
          }

          # Additional diagnostics
          echo "=== RDP DIAGNOSTICS ==="
          echo "Current RDP configuration:"
          $rdpConfig = Get-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp'
          echo "  UserAuthentication: $($rdpConfig.UserAuthentication)"
          echo "  SecurityLayer: $($rdpConfig.SecurityLayer)"
          echo "  MinEncryptionLevel: $($rdpConfig.MinEncryptionLevel)"

          $tsConfig = Get-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server'
          echo "  fDenyTSConnections: $($tsConfig.fDenyTSConnections)"

          echo "=== RDP CONFIGURATION COMPLETE ==="

        } catch {
          echo "✗ RDP configuration failed: $_"
          echo "This may cause connection issues"
        }

    - name: Create Serveo Tunnel
      run: |
        echo "=== SERVEO TUNNEL SETUP ==="
        echo "Starting Serveo tunnel for RDP access..."
        echo "Subdomain: auto-generated"

        try {
          # Enhanced Serveo tunnel creation with better error handling
          Write-Host "Creating Serveo tunnel with improved SSH handling..." -ForegroundColor Yellow

          # Find or install Plink
          $plinkPath = $null
          $possiblePaths = @("plink.exe", "plink", "C:\Program Files\PuTTY\plink.exe", "C:\Program Files (x86)\PuTTY\plink.exe")

          foreach ($path in $possiblePaths) {
            try {
              $result = & $path -V 2>&1
              if ($LASTEXITCODE -eq 0 -or $result -match "plink|PuTTY") {
                $plinkPath = $path
                Write-Host "✓ Found Plink at: $path" -ForegroundColor Green
                break
              }
            } catch { }
          }

          if (-not $plinkPath) {
            Write-Host "Installing PuTTY..." -ForegroundColor Yellow
            $puttyUrl = "https://the.earth.li/~sgtatham/putty/latest/w64/putty.zip"
            Invoke-WebRequest -Uri $puttyUrl -OutFile "putty.zip" -UseBasicParsing
            Expand-Archive -Path "putty.zip" -DestinationPath "putty" -Force
            Remove-Item "putty.zip" -Force
            $plinkPath = "putty\plink.exe"
            Write-Host "✓ PuTTY installed" -ForegroundColor Green
          }

          # Build Serveo command with enhanced options
          $tunnelSpec = "0:localhost:3389"
          $args = @(
            "-ssh", "-batch", "-T",
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=NUL",
            "-o", "ServerAliveInterval=30",
            "-o", "ConnectTimeout=30",
            "-o", "ExitOnForwardFailure=yes",
            "-v",  # Verbose output for debugging
            "-R", $tunnelSpec,
            "serveo.net"
          )

          Write-Host "Command: $plinkPath $($args -join ' ')" -ForegroundColor Gray

          # Create output files for better debugging
          $outputFile = "serveo-output.txt"
          $errorFile = "serveo-error.txt"

          # Start tunnel process with file redirection
          $psi = New-Object System.Diagnostics.ProcessStartInfo
          $psi.FileName = $plinkPath
          $psi.Arguments = $args -join " "
          $psi.UseShellExecute = $false
          $psi.RedirectStandardOutput = $true
          $psi.RedirectStandardError = $true
          $psi.CreateNoWindow = $true

          $process = [System.Diagnostics.Process]::Start($psi)
          Write-Host "✓ Plink process started (PID: $($process.Id))" -ForegroundColor Green

          # Enhanced monitoring with file-based output capture
          $tunnelUrl = $null
          $timeout = 90  # Increased timeout
          $startTime = Get-Date
          $outputBuffer = @()
          $errorBuffer = @()

          while ((Get-Date) -lt $startTime.AddSeconds($timeout) -and -not $process.HasExited -and -not $tunnelUrl) {
            # Read stdout
            if (-not $process.StandardOutput.EndOfStream) {
              try {
                $line = $process.StandardOutput.ReadLine()
                if ($line) {
                  $outputBuffer += $line
                  Write-Host "SSH OUT: $line" -ForegroundColor Gray

                  # Multiple regex patterns for different Serveo output formats
                  if ($line -match "Forwarding TCP connections from ([a-zA-Z0-9\-\.]+\.serveo\.net):(\d+)" -or
                      $line -match "tcp://([a-zA-Z0-9\-\.]+\.serveo\.net):(\d+)" -or
                      $line -match "([a-zA-Z0-9\-\.]+\.serveo\.net):(\d+)" -or
                      $line -match "https?://([a-zA-Z0-9\-\.]+\.serveo\.net)" -or
                      $line -match "Forwarding.*?([a-zA-Z0-9\-\.]+\.serveo\.net).*?(\d+)") {

                    if ($matches[2]) {
                      $tunnelUrl = "tcp://$($matches[1]):$($matches[2])"
                    } else {
                      $tunnelUrl = "tcp://$($matches[1]):3389"
                    }
                    Write-Host "✓ Tunnel URL found: $tunnelUrl" -ForegroundColor Green
                    break
                  }
                }
              } catch { }
            }

            # Read stderr
            if (-not $process.StandardError.EndOfStream) {
              try {
                $line = $process.StandardError.ReadLine()
                if ($line) {
                  $errorBuffer += $line
                  Write-Host "SSH ERR: $line" -ForegroundColor Yellow

                  # Check stderr for tunnel URLs too
                  if ($line -match "Forwarding TCP connections from ([a-zA-Z0-9\-\.]+\.serveo\.net):(\d+)" -or
                      $line -match "tcp://([a-zA-Z0-9\-\.]+\.serveo\.net):(\d+)" -or
                      $line -match "([a-zA-Z0-9\-\.]+\.serveo\.net):(\d+)") {

                    $tunnelUrl = "tcp://$($matches[1]):$($matches[2])"
                    Write-Host "✓ Tunnel URL found in stderr: $tunnelUrl" -ForegroundColor Green
                    break
                  }
                }
              } catch { }
            }

            Start-Sleep -Milliseconds 250
          }

          # Save debug output
          $outputBuffer | Out-File -FilePath $outputFile -Encoding UTF8
          $errorBuffer | Out-File -FilePath $errorFile -Encoding UTF8

          if ($tunnelUrl) {
            # Save connection details
            $connectionDetails = @{
              tunnelUrl = $tunnelUrl
              provider = "serveo"
              username = "runneradmin"
              password = "P@ssw0rd!"
              timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
              method = "putty-enhanced"
              debugOutput = ($outputBuffer -join "\n")
              debugError = ($errorBuffer -join "\n")
            }

            $connectionDetails | ConvertTo-Json | Out-File -FilePath "connection-details.json" -Encoding UTF8
            Write-Host "✓ Connection details saved" -ForegroundColor Green

            Write-Host "🎉 SERVEO TUNNEL ACTIVE!" -ForegroundColor Green
            Write-Host "Tunnel URL: $tunnelUrl" -ForegroundColor Cyan
            Write-Host "Username: runneradmin" -ForegroundColor Cyan
            Write-Host "Password: P@ssw0rd!" -ForegroundColor Cyan
          } else {
            Write-Host "✗ No tunnel URL found within timeout period" -ForegroundColor Red
            Write-Host "Debug - Last 10 output lines:" -ForegroundColor Yellow
            $outputBuffer | Select-Object -Last 10 | ForEach-Object { Write-Host "  $_" -ForegroundColor Gray }
            Write-Host "Debug - Last 10 error lines:" -ForegroundColor Yellow
            $errorBuffer | Select-Object -Last 10 | ForEach-Object { Write-Host "  $_" -ForegroundColor Gray }
            throw "No tunnel URL found within timeout period"
          }

        } catch {
          Write-Host "✗ Serveo tunnel failed: $_" -ForegroundColor Red
          
          Write-Host "Attempting failover to alternative providers..." -ForegroundColor Yellow

          # Try multiple SSH approaches with Serveo
          $fallbackSuccess = $false

          # Method 1: Direct SSH with OpenSSH
          Write-Host "Trying OpenSSH direct connection..." -ForegroundColor Yellow
          try {
            $sshArgs = @(
              "-o", "StrictHostKeyChecking=no",
              "-o", "UserKnownHostsFile=NUL",
              "-o", "ServerAliveInterval=30",
              "-o", "ConnectTimeout=20",
              "-o", "ExitOnForwardFailure=yes",
              "-v",
              "-T", "-R", "0:localhost:3389",
              "serveo.net"
            )

            # Start SSH process with output capture
            $sshProcess = Start-Process -FilePath "ssh" -ArgumentList $sshArgs -PassThru -NoNewWindow -RedirectStandardOutput "ssh-fallback-out.txt" -RedirectStandardError "ssh-fallback-err.txt"
            Write-Host "SSH process started (PID: $($sshProcess.Id))" -ForegroundColor Gray

            # Wait and monitor for tunnel establishment
            $maxWait = 45
            $checkInterval = 3
            $checks = 0

            while ($checks -lt ($maxWait / $checkInterval) -and -not $sshProcess.HasExited -and -not $fallbackSuccess) {
              Start-Sleep -Seconds $checkInterval
              $checks++

              # Check output files
              if (Test-Path "ssh-fallback-out.txt") {
                $output = Get-Content "ssh-fallback-out.txt" -Raw -ErrorAction SilentlyContinue
                if ($output -and ($output -match "Forwarding TCP connections from ([a-zA-Z0-9\-\.]+\.serveo\.net):(\d+)" -or
                                  $output -match "tcp://([a-zA-Z0-9\-\.]+\.serveo\.net):(\d+)")) {
                  $fallbackUrl = "tcp://$($matches[1]):$($matches[2])"
                  $fallbackSuccess = $true
                  break
                }
              }

              if (Test-Path "ssh-fallback-err.txt") {
                $errorOutput = Get-Content "ssh-fallback-err.txt" -Raw -ErrorAction SilentlyContinue
                if ($errorOutput -and ($errorOutput -match "Forwarding TCP connections from ([a-zA-Z0-9\-\.]+\.serveo\.net):(\d+)" -or
                                       $errorOutput -match "tcp://([a-zA-Z0-9\-\.]+\.serveo\.net):(\d+)")) {
                  $fallbackUrl = "tcp://$($matches[1]):$($matches[2])"
                  $fallbackSuccess = $true
                  break
                }
              }

              Write-Host "Waiting for tunnel... ($($checks * $checkInterval)s)" -ForegroundColor Gray
            }

            if ($fallbackSuccess) {
              Write-Host "✓ SSH fallback successful: $fallbackUrl" -ForegroundColor Green

              $connectionDetails = @{
                tunnelUrl = $fallbackUrl
                provider = "serveo-ssh-fallback"
                username = "runneradmin"
                password = "P@ssw0rd!"
                timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
                method = "ssh-direct"
              }

              $connectionDetails | ConvertTo-Json | Out-File -FilePath "connection-details.json" -Encoding UTF8
              Write-Host "🎉 FALLBACK TUNNEL ACTIVE!" -ForegroundColor Green
              Write-Host "Tunnel URL: $fallbackUrl" -ForegroundColor Cyan
              Write-Host "Username: runneradmin" -ForegroundColor Cyan
              Write-Host "Password: P@ssw0rd!" -ForegroundColor Cyan
              exit 0
            }

          } catch {
            Write-Host "✗ SSH direct fallback failed: $_" -ForegroundColor Red
          }

          # Method 2: Try Pinggy as final fallback
          if (-not $fallbackSuccess) {
            Write-Host "Trying Pinggy as final fallback..." -ForegroundColor Yellow
            try {
              # Use the same Plink approach but with Pinggy
              $plinkPath = "putty\plink.exe"
              if (Test-Path $plinkPath) {
                $pinggyArgs = @(
                  "-ssh", "-batch", "-T",
                  "-o", "StrictHostKeyChecking=no",
                  "-o", "UserKnownHostsFile=NUL",
                  "-o", "PreferredAuthentications=none",
                  "-P", "443",
                  "-R", "0:localhost:3389",
                  "tcp@a.pinggy.io"
                )

                $pinggyProcess = Start-Process -FilePath $plinkPath -ArgumentList $pinggyArgs -PassThru -NoNewWindow -RedirectStandardOutput "pinggy-fallback-out.txt" -RedirectStandardError "pinggy-fallback-err.txt"
                Start-Sleep -Seconds 30

                if (Test-Path "pinggy-fallback-out.txt") {
                  $pinggyOutput = Get-Content "pinggy-fallback-out.txt" -Raw -ErrorAction SilentlyContinue
                  if ($pinggyOutput -and $pinggyOutput -match "tcp://([a-zA-Z0-9\-\.]+\.(?:pinggy\.link|pinggy\.io)):(\d+)") {
                    $fallbackUrl = "tcp://$($matches[1]):$($matches[2])"
                    Write-Host "✓ Pinggy fallback successful: $fallbackUrl" -ForegroundColor Green

                    $connectionDetails = @{
                      tunnelUrl = $fallbackUrl
                      provider = "pinggy-fallback"
                      username = "runneradmin"
                      password = "P@ssw0rd!"
                      timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
                      method = "pinggy-fallback"
                    }

                    $connectionDetails | ConvertTo-Json | Out-File -FilePath "connection-details.json" -Encoding UTF8
                    Write-Host "🎉 PINGGY FALLBACK ACTIVE!" -ForegroundColor Green
                    Write-Host "Tunnel URL: $fallbackUrl" -ForegroundColor Cyan
                    Write-Host "Username: runneradmin" -ForegroundColor Cyan
                    Write-Host "Password: P@ssw0rd!" -ForegroundColor Cyan
                    exit 0
                  }
                }
              }
            } catch {
              Write-Host "✗ Pinggy fallback failed: $_" -ForegroundColor Red
            }
          }

          Write-Host "✗ All tunnel providers and fallbacks failed" -ForegroundColor Red
          Write-Host "Please check the GitHub Actions logs for detailed error information" -ForegroundColor Yellow
          exit 1
        }
    - name: Keep RDP Server Active
      run: |
        echo "=== RDP SERVER ACTIVE ==="
        echo "RDP server is now running and accessible"
        echo "Session will remain active for the duration of this workflow"
        echo "Maximum session time: 90 minutes (GitHub Actions limit)"
        echo ""
        echo "Connection established at: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')"
        echo "Estimated session end: $(Get-Date -Date (Get-Date).AddMinutes(85) -Format 'yyyy-MM-dd HH:mm:ss UTC')"
        echo ""
        echo "Keeping session alive..."

        # Keep alive with periodic status updates
        $startTime = Get-Date
        $maxDuration = 85 * 60  # 85 minutes in seconds
        $updateInterval = 300   # 5 minutes

        while ((Get-Date) -lt $startTime.AddSeconds($maxDuration)) {
          Start-Sleep -Seconds $updateInterval
          $elapsed = [math]::Round(((Get-Date) - $startTime).TotalMinutes, 1)
          $remaining = [math]::Round(85 - $elapsed, 1)
          echo "Session active for $elapsed minutes, $remaining minutes remaining"

          # Verify RDP service is still running
          $rdpService = Get-Service -Name "TermService" -ErrorAction SilentlyContinue
          if ($rdpService -and $rdpService.Status -eq "Running") {
            echo "✓ RDP service healthy"
          } else {
            echo "⚠ RDP service issue detected"
          }
        }

        echo "Session time limit reached, workflow ending"